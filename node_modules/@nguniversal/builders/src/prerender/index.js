/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define("@nguniversal/builders/src/prerender/index", ["require", "exports", "@angular-devkit/architect", "@angular-devkit/build-angular/src/utils/normalize-optimization", "@angular-devkit/build-angular/src/utils/service-worker", "@angular-devkit/core", "@angular-devkit/core/node", "child_process", "fs", "ora", "path", "util", "@nguniversal/builders/src/prerender/utils"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.execute = exports.readFile = void 0;
    const architect_1 = require("@angular-devkit/architect");
    const normalize_optimization_1 = require("@angular-devkit/build-angular/src/utils/normalize-optimization");
    const service_worker_1 = require("@angular-devkit/build-angular/src/utils/service-worker");
    const core_1 = require("@angular-devkit/core");
    const node_1 = require("@angular-devkit/core/node");
    const child_process_1 = require("child_process");
    const fs = require("fs");
    const ora = require("ora");
    const path = require("path");
    const util_1 = require("util");
    const utils_1 = require("@nguniversal/builders/src/prerender/utils");
    exports.readFile = util_1.promisify(fs.readFile);
    /**
     * Schedules the server and browser builds and returns their results if both builds are successful.
     */
    function _scheduleBuilds(options, context) {
        return __awaiter(this, void 0, void 0, function* () {
            const browserTarget = architect_1.targetFromTargetString(options.browserTarget);
            const serverTarget = architect_1.targetFromTargetString(options.serverTarget);
            const browserTargetRun = yield context.scheduleTarget(browserTarget, {
                watch: false,
                serviceWorker: false,
            });
            const serverTargetRun = yield context.scheduleTarget(serverTarget, {
                watch: false,
            });
            try {
                const [browserResult, serverResult] = yield Promise.all([
                    browserTargetRun.result,
                    serverTargetRun.result,
                ]);
                const success = browserResult.success && serverResult.success && browserResult.baseOutputPath !== undefined;
                const error = browserResult.error || serverResult.error;
                return { success, error, browserResult, serverResult };
            }
            catch (e) {
                return { success: false, error: e.message };
            }
            finally {
                yield Promise.all([browserTargetRun.stop(), serverTargetRun.stop()]);
            }
        });
    }
    /**
     * Renders each route and writes them to
     * <route>/index.html for each output path in the browser result.
     */
    function _renderUniversal(routes, context, browserResult, serverResult, browserOptions, numProcesses) {
        return __awaiter(this, void 0, void 0, function* () {
            const host = new node_1.NodeJsSyncHost();
            const projectName = context.target && context.target.project;
            if (!projectName) {
                throw new Error('The builder requires a target.');
            }
            const root = core_1.normalize(context.workspaceRoot);
            const projectMetadata = yield context.getProjectMetadata(projectName);
            const projectRoot = core_1.resolve(root, core_1.normalize(projectMetadata.root || ''));
            // Users can specify a different base html file e.g. "src/home.html"
            const indexFile = utils_1.getIndexOutputFile(browserOptions);
            const { styles: normalizedStylesOptimization } = normalize_optimization_1.normalizeOptimization(browserOptions.optimization);
            // We need to render the routes for each locale from the browser output.
            for (const outputPath of browserResult.outputPaths) {
                const browserIndexInputPath = path.join(outputPath, indexFile);
                let indexHtml = yield exports.readFile(browserIndexInputPath, 'utf8');
                if (normalizedStylesOptimization.inlineCritical) {
                    // Workaround for https://github.com/GoogleChromeLabs/critters/issues/64
                    indexHtml = indexHtml.replace(/ media=\"print\" onload=\"this\.media='all'"><noscript><link .+?><\/noscript>/g, '>');
                }
                const { baseOutputPath = '' } = serverResult;
                const localeDirectory = path.relative(browserResult.baseOutputPath, outputPath);
                const serverBundlePath = path.join(baseOutputPath, localeDirectory, 'main.js');
                if (!fs.existsSync(serverBundlePath)) {
                    throw new Error(`Could not find the main bundle: ${serverBundlePath}`);
                }
                const spinner = ora(`Prerendering ${routes.length} route(s) to ${outputPath}...`).start();
                try {
                    const workerFile = path.join(__dirname, 'render.js');
                    const childProcesses = utils_1.shardArray(routes, numProcesses)
                        .map(routesShard => new Promise((resolve, reject) => {
                        child_process_1.fork(workerFile, [
                            indexHtml.replace('</html>', '<!-- This page was prerendered with Angular Universal -->\n</html>'),
                            indexFile,
                            serverBundlePath,
                            outputPath,
                            browserOptions.deployUrl || '',
                            normalizedStylesOptimization.inlineCritical === true ? 'true' : 'false',
                            normalizedStylesOptimization.minify === true ? 'true' : 'false',
                            ...routesShard,
                        ])
                            .on('message', data => {
                            if (data.success === false) {
                                reject(new Error(`Unable to render ${data.outputIndexPath}.\nError: ${data.error}`));
                                return;
                            }
                            if (data.logLevel) {
                                spinner.stop();
                                context.logger.log(data.logLevel, data.message);
                                spinner.start();
                            }
                        })
                            .on('exit', resolve)
                            .on('error', reject);
                    }));
                    yield Promise.all(childProcesses);
                }
                catch (error) {
                    spinner.fail(`Prerendering routes to ${outputPath} failed.`);
                    return { success: false, error: error.message };
                }
                spinner.succeed(`Prerendering routes to ${outputPath} complete.`);
                if (browserOptions.serviceWorker) {
                    spinner.start('Generating service worker...');
                    try {
                        yield service_worker_1.augmentAppWithServiceWorker(root, projectRoot, core_1.normalize(outputPath), browserOptions.baseHref || '/', browserOptions.ngswConfigPath);
                    }
                    catch (error) {
                        spinner.fail('Service worker generation failed.');
                        return { success: false, error: error.message };
                    }
                    spinner.succeed('Service worker generation complete.');
                }
            }
            return browserResult;
        });
    }
    /**
     * Builds the browser and server, then renders each route in options.routes
     * and writes them to prerender/<route>/index.html for each output path in
     * the browser result.
     */
    function execute(options, context) {
        return __awaiter(this, void 0, void 0, function* () {
            const browserTarget = architect_1.targetFromTargetString(options.browserTarget);
            const browserOptions = yield context.getTargetOptions(browserTarget);
            const tsConfigPath = typeof browserOptions.tsConfig === 'string' ? browserOptions.tsConfig : undefined;
            const routes = yield utils_1.getRoutes(options, tsConfigPath, context);
            if (!routes.length) {
                throw new Error(`Could not find any routes to prerender.`);
            }
            const result = yield _scheduleBuilds(options, context);
            const { success, error, browserResult, serverResult } = result;
            if (!success || !browserResult || !serverResult) {
                return { success, error };
            }
            return _renderUniversal(routes, context, browserResult, serverResult, browserOptions, options.numProcesses);
        });
    }
    exports.execute = execute;
    exports.default = architect_1.createBuilder(execute);
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi9tb2R1bGVzL2J1aWxkZXJzL3NyYy9wcmVyZW5kZXIvaW5kZXgudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7OztHQU1HOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lBRUgseURBQWlIO0lBRWpILDJHQUF1RztJQUN2RywyRkFBcUc7SUFDckcsK0NBQXlFO0lBQ3pFLG9EQUEyRDtJQUMzRCxpREFBcUM7SUFDckMseUJBQXlCO0lBQ3pCLDJCQUEyQjtJQUMzQiw2QkFBNkI7SUFDN0IsK0JBQWlDO0lBRWpDLHFFQUFvRTtJQUV2RCxRQUFBLFFBQVEsR0FBRyxnQkFBUyxDQUFDLEVBQUUsQ0FBQyxRQUFRLENBQUMsQ0FBQztJQWMvQzs7T0FFRztJQUNILFNBQWUsZUFBZSxDQUM1QixPQUFnQyxFQUNoQyxPQUF1Qjs7WUFFdkIsTUFBTSxhQUFhLEdBQUcsa0NBQXNCLENBQUMsT0FBTyxDQUFDLGFBQWEsQ0FBQyxDQUFDO1lBQ3BFLE1BQU0sWUFBWSxHQUFHLGtDQUFzQixDQUFDLE9BQU8sQ0FBQyxZQUFZLENBQUMsQ0FBQztZQUVsRSxNQUFNLGdCQUFnQixHQUFHLE1BQU0sT0FBTyxDQUFDLGNBQWMsQ0FBQyxhQUFhLEVBQUU7Z0JBQ25FLEtBQUssRUFBRSxLQUFLO2dCQUNaLGFBQWEsRUFBRSxLQUFLO2FBRXJCLENBQUMsQ0FBQztZQUNILE1BQU0sZUFBZSxHQUFHLE1BQU0sT0FBTyxDQUFDLGNBQWMsQ0FBQyxZQUFZLEVBQUU7Z0JBQ2pFLEtBQUssRUFBRSxLQUFLO2FBQ2IsQ0FBQyxDQUFDO1lBRUgsSUFBSTtnQkFDRixNQUFNLENBQUMsYUFBYSxFQUFFLFlBQVksQ0FBQyxHQUFHLE1BQU0sT0FBTyxDQUFDLEdBQUcsQ0FBQztvQkFDdEQsZ0JBQWdCLENBQUMsTUFBdUM7b0JBQ3hELGVBQWUsQ0FBQyxNQUF1QztpQkFDeEQsQ0FBQyxDQUFDO2dC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QUFnQyxFQUNoQyxPQUF1Qjs7WUFFdkIsTUFBTSxhQUFhLEdBQUcsa0NBQXNCLENBQUMsT0FBTyxDQUFDLGFBQWEsQ0FBQyxDQUFDO1lBQ3BFLE1BQU0sY0FBYyxHQUNsQixNQUFNLE9BQU8sQ0FBQyxnQkFBZ0IsQ0FBQyxhQUFhLENBQXFDLENBQUM7WUFDcEYsTUFBTSxZQUFZLEdBQ2hCLE9BQU8sY0FBYyxDQUFDLFFBQVEsS0FBSyxRQUFRLENBQUMsQ0FBQyxDQUFDLGNBQWMsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQztZQUVwRixNQUFNLE1BQU0sR0FBRyxNQUFNLGlCQUFTLENBQUMsT0FBTyxFQUFFLFlBQVksRUFBRSxPQUFPLENBQUMsQ0FBQztZQUMvRCxJQUFJLENBQUMsTUFBTSxDQUFDLE1BQU0sRUFBRTtnQkFDbEIsTUFBTSxJQUFJLEtBQUssQ0FBQyx5Q0FBeUMsQ0FBQyxDQUFDO2FBQzVEO1lBRUQsTUFBTSxNQUFNLEdBQUcsTUFBTSxlQUFlLENBQUMsT0FBTyxFQUFFLE9BQU8sQ0FBQyxDQUFDO1lBQ3ZELE1BQU0sRUFBRSxPQUFPLEVBQUUsS0FBSyxFQUFFLGFBQWEsRUFBRSxZQUFZLEVBQUUsR0FBRyxNQUFNLENBQUM7WUFDL0QsSUFBSSxDQUFDLE9BQU8sSUFBSSxDQUFDLGFBQWEsSUFBSSxDQUFDLFlBQVksRUFBRTtnQkFDL0MsT0FBTyxFQUFFLE9BQU8sRUFBRSxLQUFLLEVBQW1CLENBQUM7YUFDNUM7WUFFRCxPQUFPLGdCQUFnQixDQUNyQixNQUFNLEVBQ04sT0FBTyxFQUNQLGFBQWEsRUFDYixZQUFZLEVBQ1osY0FBYyxFQUNkLE9BQU8sQ0FBQyxZQUFZLENBQ3JCLENBQUM7UUFDSixDQUFDO0tBQUE7SUE3QkQsMEJBNkJDO0lBRUQsa0JBQWUseUJBQWEsQ0FBQyxPQUFPLENBQUMsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuXG5pbXBvcnQgeyBCdWlsZGVyQ29udGV4dCwgQnVpbGRlck91dHB1dCwgY3JlYXRlQnVpbGRlciwgdGFyZ2V0RnJvbVRhcmdldFN0cmluZyB9IGZyb20gJ0Bhbmd1bGFyLWRldmtpdC9hcmNoaXRlY3QnO1xuaW1wb3J0IHsgQnJvd3NlckJ1aWxkZXJPcHRpb25zIH0gZnJvbSAnQGFuZ3VsYXItZGV2a2l0L2J1aWxkLWFuZ3VsYXInO1xuaW1wb3J0IHsgbm9ybWFsaXplT3B0aW1pemF0aW9uIH0gZnJvbSAnQGFuZ3VsYXItZGV2a2l0L2J1aWxkLWFuZ3VsYXIvc3JjL3V0aWxzL25vcm1hbGl6ZS1vcHRpbWl6YXRpb24nO1xuaW1wb3J0IHsgYXVnbWVudEFwcFdpdGhTZXJ2aWNlV29ya2VyIH0gZnJvbSAnQGFuZ3VsYXItZGV2a2l0L2J1aWxkLWFuZ3VsYXIvc3JjL3V0aWxzL3NlcnZpY2Utd29ya2VyJztcbmltcG9ydCB7IG5vcm1hbGl6ZSwgcmVzb2x2ZSBhcyByZXNvbHZlUGF0aCB9IGZyb20gJ0Bhbmd1bGFyLWRldmtpdC9jb3JlJztcbmltcG9ydCB7IE5vZGVKc1N5bmNIb3N0IH0gZnJvbSAnQGFuZ3VsYXItZGV2a2l0L2NvcmUvbm9kZSc7XG5pbXBvcnQgeyBmb3JrIH0gZnJvbSAnY2hpbGRfcHJvY2Vzcyc7XG5pbXBvcnQgKiBhcyBmcyBmcm9tICdmcyc7XG5pbXBvcnQgKiBhcyBvcmEgZnJvbSAnb3JhJztcbmltcG9ydCAqIGFzIHBhdGggZnJvbSAncGF0aCc7XG5pbXBvcnQgeyBwcm9taXNpZnkgfSBmcm9tICd1dGlsJztcbmltcG9ydCB7IFByZXJlbmRlckJ1aWxkZXJPcHRpb25zLCBQcmVyZW5kZXJCdWlsZGVyT3V0cHV0IH0gZnJvbSAnLi9tb2RlbHMnO1xuaW1wb3J0IHsgZ2V0SW5kZXhPdXRwdXRGaWxlLCBnZXRSb3V0ZXMsIHNoYXJkQXJyYXkgfSBmcm9tICcuL3V0aWxzJztcblxuZXhwb3J0IGNvbnN0IHJlYWRGaWxlID0gcHJvbWlzaWZ5KGZzLnJlYWRGaWxlKTtcblxuXG50eXBlIEJ1aWxkQnVpbGRlck91dHB1dCA9IEJ1aWxkZXJPdXRwdXQgJiB7XG4gIGJhc2VPdXRwdXRQYXRoOiBzdHJpbmc7XG4gIG91dHB1dFBhdGhzOiBzdHJpbmdbXTtcbiAgb3V0cHV0UGF0aDogc3RyaW5nO1xufTtcblxudHlwZSBTY2hlZHVsZUJ1aWxkc091dHB1dCA9IEJ1aWxkZXJPdXRwdXQgJiB7XG4gIHNlcnZlclJlc3VsdD86IEJ1aWxkQnVpbGRlck91dHB1dDtcbiAgYnJvd3NlclJlc3VsdD86IEJ1aWxkQnVpbGRlck91dHB1dDtcbn07XG5cbi8qKlxuICogU2NoZWR1bGVzIHRoZSBzZXJ2ZXIgYW5kIGJyb3dzZXIgYnVpbGRzIGFuZCByZXR1cm5zIHRoZWlyIHJlc3VsdHMgaWYgYm90aCBidWlsZHMgYXJlIHN1Y2Nlc3NmdWwuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIF9zY2hlZHVsZUJ1aWxkcyhcbiAgb3B0aW9uczogUHJlcmVuZGVyQnVpbGRlck9wdGlvbnMsXG4gIGNvbnRleHQ6IEJ1aWxkZXJDb250ZXh0XG4pOiBQcm9taXNlPFNjaGVkdWxlQnVpbGRzT3V0cHV0PiB7XG4gIGNvbnN0IGJyb3dzZXJUYXJnZXQgPSB0YXJnZXRGcm9tVGFyZ2V0U3RyaW5nKG9wdGlvbnMuYnJvd3NlclRhcmdldCk7XG4gIGNvbnN0IHNlcnZlclRhcmdldCA9IHRhcmdldEZyb21UYXJnZXRTdHJpbmcob3B0aW9ucy5zZXJ2ZXJUYXJnZXQpO1xuXG4gIGNvbnN0IGJyb3dzZXJUYXJnZXRSdW4gPSBhd2FpdCBjb250ZXh0LnNjaGVkdWxlVGFyZ2V0KGJyb3dzZXJUYXJnZXQsIHtcbiAgICB3YXRjaDogZmFsc2UsXG4gICAgc2VydmljZVdvcmtlcjogZmFsc2UsXG4gICAgLy8gdG9kbzogaGFuZGxlIHNlcnZpY2Ugd29ya2VyIGF1Z21lbnRhdGlvblxuICB9KTtcbiAgY29uc3Qgc2VydmVyVGFyZ2V0UnVuID0gYXdhaXQgY29udGV4dC5zY2hlZHVsZVRhcmdldChzZXJ2ZXJUYXJnZXQsIHtcbiAgICB3YXRjaDogZmFsc2UsXG4gIH0pO1xuXG4gIHRyeSB7XG4gICAgY29uc3QgW2Jyb3dzZXJSZXN1bHQsIHNlcnZlclJlc3VsdF0gPSBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICBicm93c2VyVGFyZ2V0UnVuLnJlc3VsdCBhcyB1bmtub3duIGFzIEJ1aWxkQnVpbGRlck91dHB1dCxcbiAgICAgIHNlcnZlclRhcmdldFJ1bi5yZXN1bHQgYXMgdW5rbm93biBhcyBCdWlsZEJ1aWxkZXJPdXRwdXQsXG4gICAgXSk7XG5cbiAgICBjb25zdCBzdWNjZXNzID1cbiAgICAgIGJyb3dzZXJSZXN1bHQuc3VjY2VzcyAmJiBzZXJ2ZXJSZXN1bHQuc3VjY2VzcyAmJiBicm93c2VyUmVzdWx0LmJhc2VPdXRwdXRQYXRoICE9PSB1bmRlZmluZWQ7XG4gICAgY29uc3QgZXJyb3IgPSBicm93c2VyUmVzdWx0LmVycm9yIHx8IHNlcnZlclJlc3VsdC5lcnJvciBhcyBzdHJpbmc7XG5cbiAgICByZXR1cm4geyBzdWNjZXNzLCBlcnJvciwgYnJvd3NlclJlc3VsdCwgc2VydmVyUmVzdWx0IH07XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6IGUubWVzc2FnZSB9O1xuICB9IGZpbmFsbHkge1xuICAgIGF3YWl0IFByb21pc2UuYWxsKFticm93c2VyVGFyZ2V0UnVuLnN0b3AoKSwgc2VydmVyVGFyZ2V0UnVuLnN0b3AoKV0pO1xuICB9XG59XG5cbi8qKlxuICogUmVuZGVycyBlYWNoIHJvdXRlIGFuZCB3cml0ZXMgdGhlbSB0b1xuICogPHJvdXRlPi9pbmRleC5odG1sIGZvciBlYWNoIG91dHB1dCBwYXRoIGluIHRoZSBicm93c2VyIHJlc3VsdC5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gX3JlbmRlclVuaXZlcnNhbChcbiAgcm91dGVzOiBzdHJpbmdbXSxcbiAgY29udGV4dDogQnVpbGRlckNvbnRleHQsXG4gIGJyb3dzZXJSZXN1bHQ6IEJ1aWxkQnVpbGRlck91dHB1dCxcbiAgc2VydmVyUmVzdWx0OiBCdWlsZEJ1aWxkZXJPdXRwdXQsXG4gIGJyb3dzZXJPcHRpb25zOiBCcm93c2VyQnVpbGRlck9wdGlvbnMsXG4gIG51bVByb2Nlc3Nlcz86IG51bWJlcixcbik6IFByb21pc2U8UHJlcmVuZGVyQnVpbGRlck91dHB1dD4ge1xuICBjb25zdCBob3N0ID0gbmV3IE5vZGVKc1N5bmNIb3N0KCk7XG4gIGNvbnN0IHByb2plY3ROYW1lID0gY29udGV4dC50YXJnZXQgJiYgY29udGV4dC50YXJnZXQucHJvamVjdDtcbiAgaWYgKCFwcm9qZWN0TmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignVGhlIGJ1aWxkZXIgcmVxdWlyZXMgYSB0YXJnZXQuJyk7XG4gIH1cblxuICBjb25zdCByb290ID0gbm9ybWFsaXplKGNvbnRleHQud29ya3NwYWNlUm9vdCk7XG4gIGNvbnN0IHByb2plY3RNZXRhZGF0YSA9IGF3YWl0IGNvbnRleHQuZ2V0UHJvamVjdE1ldGFkYXRhKHByb2plY3ROYW1lKTtcbiAgY29uc3QgcHJvamVjdFJvb3QgPSByZXNvbHZlUGF0aChcbiAgICByb290LFxuICAgIG5vcm1hbGl6ZSgocHJvamVjdE1ldGFkYXRhLnJvb3QgYXMgc3RyaW5nKSB8fCAnJyksXG4gICk7XG5cbiAgLy8gVXNlcnMgY2FuIHNwZWNpZnkgYSBkaWZmZXJlbnQgYmFzZSBodG1sIGZpbGUgZS5nLiBcInNyYy9ob21lLmh0bWxcIlxuICBjb25zdCBpbmRleEZpbGUgPSBnZXRJbmRleE91dHB1dEZpbGUoYnJvd3Nlck9wdGlvbnMpO1xuICBjb25zdCB7IHN0eWxlczogbm9ybWFsaXplZFN0eWxlc09wdGltaXphdGlvbiB9ID0gbm9ybWFsaXplT3B0aW1pemF0aW9uKGJyb3dzZXJPcHRpb25zLm9wdGltaXphdGlvbik7XG5cbiAgLy8gV2UgbmVlZCB0byByZW5kZXIgdGhlIHJvdXRlcyBmb3IgZWFjaCBsb2NhbGUgZnJvbSB0aGUgYnJvd3NlciBvdXRwdXQuXG4gIGZvciAoY29uc3Qgb3V0cHV0UGF0aCBvZiBicm93c2VyUmVzdWx0Lm91dHB1dFBhdGhzKSB7XG4gICAgY29uc3QgYnJvd3NlckluZGV4SW5wdXRQYXRoID0gcGF0aC5qb2luKG91dHB1dFBhdGgsIGluZGV4RmlsZSk7XG4gICAgbGV0IGluZGV4SHRtbCA9IGF3YWl0IHJlYWRGaWxlKGJyb3dzZXJJbmRleElucHV0UGF0aCwgJ3V0ZjgnKTtcblxuICAgIGlmIChub3JtYWxpemVkU3R5bGVzT3B0aW1pemF0aW9uLmlubGluZUNyaXRpY2FsKSB7XG4gICAgICAvLyBXb3JrYXJvdW5kIGZvciBodHRwczovL2dpdGh1Yi5jb20vR29vZ2xlQ2hyb21lTGFicy9jcml0dGVycy9pc3N1ZXMvNjRcbiAgICAgIGluZGV4SHRtbCA9IGluZGV4SHRtbC5yZXBsYWNlKC8gbWVkaWE9XFxcInByaW50XFxcIiBvbmxvYWQ9XFxcInRoaXNcXC5tZWRpYT0nYWxsJ1wiPjxub3NjcmlwdD48bGluayAuKz8+PFxcL25vc2NyaXB0Pi9nLCAnPicpO1xuICAgIH1cblxuICAgIGNvbnN0IHsgYmFzZU91dHB1dFBhdGggPSAnJyB9ID0gc2VydmVyUmVzdWx0O1xuICAgIGNvbnN0IGxvY2FsZURpcmVjdG9yeSA9IHBhdGgucmVsYXRpdmUoYnJvd3NlclJlc3VsdC5iYXNlT3V0cHV0UGF0aCwgb3V0cHV0UGF0aCk7XG4gICAgY29uc3Qgc2VydmVyQnVuZGxlUGF0aCA9IHBhdGguam9pbihiYXNlT3V0cHV0UGF0aCwgbG9jYWxlRGlyZWN0b3J5LCAnbWFpbi5qcycpO1xuICAgIGlmICghZnMuZXhpc3RzU3luYyhzZXJ2ZXJCdW5kbGVQYXRoKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb3VsZCBub3QgZmluZCB0aGUgbWFpbiBidW5kbGU6ICR7c2VydmVyQnVuZGxlUGF0aH1gKTtcbiAgICB9XG5cbiAgICBjb25zdCBzcGlubmVyID0gb3JhKGBQcmVyZW5kZXJpbmcgJHtyb3V0ZXMubGVuZ3RofSByb3V0ZShzKSB0byAke291dHB1dFBhdGh9Li4uYCkuc3RhcnQoKTtcblxuICAgIHRyeSB7XG4gICAgICBjb25zdCB3b3JrZXJGaWxlID0gcGF0aC5qb2luKF9fZGlybmFtZSwgJ3JlbmRlci5qcycpO1xuICAgICAgY29uc3QgY2hpbGRQcm9jZXNzZXMgPSBzaGFyZEFycmF5KHJvdXRlcywgbnVtUHJvY2Vzc2VzKVxuICAgICAgICAubWFwKHJvdXRlc1NoYXJkID0+XG4gICAgICAgICAgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgZm9yayh3b3JrZXJGaWxlLCBbXG4gICAgICAgICAgICAgIGluZGV4SHRtbC5yZXBsYWNlKCc8L2h0bWw+JywgJzwhLS0gVGhpcyBwYWdlIHdhcyBwcmVyZW5kZXJlZCB3aXRoIEFuZ3VsYXIgVW5pdmVyc2FsIC0tPlxcbjwvaHRtbD4nKSxcbiAgICAgICAgICAgICAgaW5kZXhGaWxlLFxuICAgICAgICAgICAgICBzZXJ2ZXJCdW5kbGVQYXRoLFxuICAgICAgICAgICAgICBvdXRwdXRQYXRoLFxuICAgICAgICAgICAgICBicm93c2VyT3B0aW9ucy5kZXBsb3lVcmwgfHwgJycsXG4gICAgICAgICAgICAgIG5vcm1hbGl6ZWRTdHlsZXNPcHRpbWl6YXRpb24uaW5saW5lQ3JpdGljYWwgPT09IHRydWUgPyAndHJ1ZScgOiAnZmFsc2UnICxcbiAgICAgICAgICAgICAgbm9ybWFsaXplZFN0eWxlc09wdGltaXphdGlvbi5taW5pZnkgPT09IHRydWUgPyAndHJ1ZScgOiAnZmFsc2UnICxcbiAgICAgICAgICAgICAgLi4ucm91dGVzU2hhcmQsXG4gICAgICAgICAgICBdKVxuICAgICAgICAgICAgICAub24oJ21lc3NhZ2UnLCBkYXRhID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZGF0YS5zdWNjZXNzID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihgVW5hYmxlIHRvIHJlbmRlciAke2RhdGEub3V0cHV0SW5kZXhQYXRofS5cXG5FcnJvcjogJHtkYXRhLmVycm9yfWApKTtcblxuICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChkYXRhLmxvZ0xldmVsKSB7XG4gICAgICAgICAgICAgICAgICBzcGlubmVyLnN0b3AoKTtcbiAgICAgICAgICAgICAgICAgIGNvbnRleHQubG9nZ2VyLmxvZyhkYXRhLmxvZ0xldmVsLCBkYXRhLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgc3Bpbm5lci5zdGFydCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgLm9uKCdleGl0JywgcmVzb2x2ZSlcbiAgICAgICAgICAgICAgLm9uKCdlcnJvcicsIHJlamVjdCk7XG4gICAgICAgICAgfSlcbiAgICAgICAgKTtcblxuICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoY2hpbGRQcm9jZXNzZXMpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBzcGlubmVyLmZhaWwoYFByZXJlbmRlcmluZyByb3V0ZXMgdG8gJHtvdXRwdXRQYXRofSBmYWlsZWQuYCk7XG5cbiAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogZXJyb3IubWVzc2FnZSB9O1xuICAgIH1cblxuICAgIHNwaW5uZXIuc3VjY2VlZChgUHJlcmVuZGVyaW5nIHJvdXRlcyB0byAke291dHB1dFBhdGh9IGNvbXBsZXRlLmApO1xuXG4gICAgaWYgKGJyb3dzZXJPcHRpb25zLnNlcnZpY2VXb3JrZXIpIHtcbiAgICAgIHNwaW5uZXIuc3RhcnQoJ0dlbmVyYXRpbmcgc2VydmljZSB3b3JrZXIuLi4nKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IGF1Z21lbnRBcHBXaXRoU2VydmljZVdvcmtlcihcbiAgICAgICAgICByb290LFxuICAgICAgICAgIHByb2plY3RSb290LFxuICAgICAgICAgIG5vcm1hbGl6ZShvdXRwdXRQYXRoKSxcbiAgICAgICAgICBicm93c2VyT3B0aW9ucy5iYXNlSHJlZiB8fCAnLycsXG4gICAgICAgICAgYnJvd3Nlck9wdGlvbnMubmdzd0NvbmZpZ1BhdGgsXG4gICAgICAgICk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBzcGlubmVyLmZhaWwoJ1NlcnZpY2Ugd29ya2VyIGdlbmVyYXRpb24gZmFpbGVkLicpO1xuXG4gICAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogZXJyb3IubWVzc2FnZSB9O1xuICAgICAgfVxuXG4gICAgICBzcGlubmVyLnN1Y2NlZWQoJ1NlcnZpY2Ugd29ya2VyIGdlbmVyYXRpb24gY29tcGxldGUuJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJyb3dzZXJSZXN1bHQ7XG59XG5cbi8qKlxuICogQnVpbGRzIHRoZSBicm93c2VyIGFuZCBzZXJ2ZXIsIHRoZW4gcmVuZGVycyBlYWNoIHJvdXRlIGluIG9wdGlvbnMucm91dGVzXG4gKiBhbmQgd3JpdGVzIHRoZW0gdG8gcHJlcmVuZGVyLzxyb3V0ZT4vaW5kZXguaHRtbCBmb3IgZWFjaCBvdXRwdXQgcGF0aCBpblxuICogdGhlIGJyb3dzZXIgcmVzdWx0LlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZXhlY3V0ZShcbiAgb3B0aW9uczogUHJlcmVuZGVyQnVpbGRlck9wdGlvbnMsXG4gIGNvbnRleHQ6IEJ1aWxkZXJDb250ZXh0XG4pOiBQcm9taXNlPFByZXJlbmRlckJ1aWxkZXJPdXRwdXQ+IHtcbiAgY29uc3QgYnJvd3NlclRhcmdldCA9IHRhcmdldEZyb21UYXJnZXRTdHJpbmcob3B0aW9ucy5icm93c2VyVGFyZ2V0KTtcbiAgY29uc3QgYnJvd3Nlck9wdGlvbnMgPVxuICAgIGF3YWl0IGNvbnRleHQuZ2V0VGFyZ2V0T3B0aW9ucyhicm93c2VyVGFyZ2V0KSBhcyB1bmtub3duIGFzIEJyb3dzZXJCdWlsZGVyT3B0aW9ucztcbiAgY29uc3QgdHNDb25maWdQYXRoID1cbiAgICB0eXBlb2YgYnJvd3Nlck9wdGlvbnMudHNDb25maWcgPT09ICdzdHJpbmcnID8gYnJvd3Nlck9wdGlvbnMudHNDb25maWcgOiB1bmRlZmluZWQ7XG5cbiAgY29uc3Qgcm91dGVzID0gYXdhaXQgZ2V0Um91dGVzKG9wdGlvbnMsIHRzQ29uZmlnUGF0aCwgY29udGV4dCk7XG4gIGlmICghcm91dGVzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgQ291bGQgbm90IGZpbmQgYW55IHJvdXRlcyB0byBwcmVyZW5kZXIuYCk7XG4gIH1cblxuICBjb25zdCByZXN1bHQgPSBhd2FpdCBfc2NoZWR1bGVCdWlsZHMob3B0aW9ucywgY29udGV4dCk7XG4gIGNvbnN0IHsgc3VjY2VzcywgZXJyb3IsIGJyb3dzZXJSZXN1bHQsIHNlcnZlclJlc3VsdCB9ID0gcmVzdWx0O1xuICBpZiAoIXN1Y2Nlc3MgfHwgIWJyb3dzZXJSZXN1bHQgfHwgIXNlcnZlclJlc3VsdCkge1xuICAgIHJldHVybiB7IHN1Y2Nlc3MsIGVycm9yIH0gYXMgQnVpbGRlck91dHB1dDtcbiAgfVxuXG4gIHJldHVybiBfcmVuZGVyVW5pdmVyc2FsKFxuICAgIHJvdXRlcyxcbiAgICBjb250ZXh0LFxuICAgIGJyb3dzZXJSZXN1bHQsXG4gICAgc2VydmVyUmVzdWx0LFxuICAgIGJyb3dzZXJPcHRpb25zLFxuICAgIG9wdGlvbnMubnVtUHJvY2Vzc2VzLFxuICApO1xufVxuXG5leHBvcnQgZGVmYXVsdCBjcmVhdGVCdWlsZGVyKGV4ZWN1dGUpO1xuIl19